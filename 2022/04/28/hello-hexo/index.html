<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>hello hexo! | 苇名妖梦</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我也要有自己的博客了吗！随便放点东西测试一下。 Lec.9 多态与模板纯虚函数与抽象类 虚函数还可以进一步声明为纯虚函数（如下所示），包含纯虚函数的类，通常被称为“抽象类”。virtual 返回类型 函数名(形式参数) &#x3D; 0;   抽象类不允许定义对象，定义基类为抽象类的主要用途是为派生类规定共性“接口”  特点： •不允许定义对象。 •只能为派生类提供接口。 •能避免对象切片：保证只">
<meta property="og:type" content="article">
<meta property="og:title" content="hello hexo!">
<meta property="og:url" content="https://sekiroyoumu.github.io/SekiroBlog/2022/04/28/hello-hexo/index.html">
<meta property="og:site_name" content="苇名妖梦">
<meta property="og:description" content="我也要有自己的博客了吗！随便放点东西测试一下。 Lec.9 多态与模板纯虚函数与抽象类 虚函数还可以进一步声明为纯虚函数（如下所示），包含纯虚函数的类，通常被称为“抽象类”。virtual 返回类型 函数名(形式参数) &#x3D; 0;   抽象类不允许定义对象，定义基类为抽象类的主要用途是为派生类规定共性“接口”  特点： •不允许定义对象。 •只能为派生类提供接口。 •能避免对象切片：保证只">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sekiroyoumu.github.io/SekiroBlog/Lec.9.assets/image-20220418133937541.png">
<meta property="og:image" content="https://sekiroyoumu.github.io/SekiroBlog/Lec.9.assets/image-20220425162411624.png">
<meta property="og:image" content="https://sekiroyoumu.github.io/SekiroBlog/Lec.9.assets/image-20220418140501192.png">
<meta property="og:image" content="https://sekiroyoumu.github.io/SekiroBlog/Lec.9.assets/image-20220418140827399.png">
<meta property="og:image" content="https://sekiroyoumu.github.io/SekiroBlog/Lec.9.assets/image-20220425164056101.png">
<meta property="og:image" content="https://sekiroyoumu.github.io/SekiroBlog/Lec.9.assets/image-20220418142236127.png">
<meta property="og:image" content="https://sekiroyoumu.github.io/SekiroBlog/Lec.9.assets/image-20220418143002571.png">
<meta property="og:image" content="https://sekiroyoumu.github.io/SekiroBlog/Lec.9.assets/image-20220418143338219.png">
<meta property="og:image" content="https://sekiroyoumu.github.io/SekiroBlog/Lec.9.assets/image-20220418143702100.png">
<meta property="og:image" content="https://sekiroyoumu.github.io/SekiroBlog/Lec.9.assets/image-20220418143709266.png">
<meta property="article:published_time" content="2022-04-28T07:30:41.000Z">
<meta property="article:modified_time" content="2022-04-28T07:31:11.863Z">
<meta property="article:author" content="Fangyi Chen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sekiroyoumu.github.io/SekiroBlog/Lec.9.assets/image-20220418133937541.png">
  
    <link rel="alternate" href="/SekiroBlog/atom.xml" title="苇名妖梦" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/SekiroBlog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/SekiroBlog/css/style.css">

  
    
<link rel="stylesheet" href="/SekiroBlog/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/SekiroBlog/" id="logo">苇名妖梦</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/SekiroBlog/" id="subtitle">非典型天坑人的自留地</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/SekiroBlog/">Home</a>
        
          <a class="main-nav-link" href="/SekiroBlog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/SekiroBlog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://sekiroyoumu.github.io/SekiroBlog"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-hello-hexo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/SekiroBlog/2022/04/28/hello-hexo/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T07:30:41.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      hello hexo!
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我也要有自己的博客了吗！<br>随便放点东西测试一下。</p>
<h2 id="Lec-9-多态与模板"><a href="#Lec-9-多态与模板" class="headerlink" title="Lec.9 多态与模板"></a>Lec.9 多态与模板</h2><h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><ul>
<li><p>虚函数还可以进一步声明为纯虚函数（如下所示），包含纯虚函数的类，通常被称为<strong>“抽象类”</strong>。<br>virtual 返回类型 函数名(形式参数) &#x3D; 0; </p>
</li>
<li><p>抽象类<strong>不允许定义对象</strong>，定义基类为抽象类的主要用途是为派生类<strong>规定共性“接口</strong>”</p>
</li>
<li><p><strong>特点：</strong></p>
<p>•不允许定义对象。</p>
<p>•只能<strong>为派生类提供接口</strong>。</p>
<p>•能避免对象切片：保证只有指针和引用能被向上类型转换。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">/// 可在类外定义函数体提供默认实现。派生类通过 A::f() 调用</span></span><br><span class="line">&#125;;</span><br><span class="line">A obj; <span class="comment">/// 不准抽象类定义对象！编译不通过！</span></span><br></pre></td></tr></table></figure>

<p><img src="/SekiroBlog/Lec.9.assets/image-20220418133937541.png" alt="image-20220418133937541"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">motion</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pet::motion</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Pet motion: &quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="keyword">public</span> Pet &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">motion</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;Pet::<span class="built_in">motion</span>(); cout &lt;&lt; <span class="string">&quot;dog run&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>: <span class="keyword">public</span> Pet &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">motion</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;Pet::<span class="built_in">motion</span>(); cout &lt;&lt; <span class="string">&quot;bird fly&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Pet* p = <span class="keyword">new</span> Dog; <span class="comment">/// 向上类型转换</span></span><br><span class="line">  p-&gt;<span class="built_in">motion</span>();</span><br><span class="line">  p = <span class="keyword">new</span> Bird; <span class="comment">/// 向上类型转换</span></span><br><span class="line">  p-&gt;<span class="built_in">motion</span>();</span><br><span class="line">  <span class="comment">//p = new Pet; /// 不允许定义抽象类对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基类纯虚函数被派生类重写覆盖之前仍是纯虚函数。因此当继承一个抽象类时，除纯虚析构函数外（后面解释），必须实现（重写覆盖）所有纯虚函数，否则继承出的类也是抽象类。</p>
<p>why?</p>
<p>对于纯虚析构函数而言，即便派生类中不显式实现，编译器<strong>也会自动合成默认析构函数</strong>。因此，即使派生类不显式覆盖纯虚析构函数，只要派生类覆盖了其他纯虚函数，该派生类就不是抽象类，可以定义派生类对象。</p>
<h4 id="纯虚析构函数"><a href="#纯虚析构函数" class="headerlink" title="纯虚析构函数"></a>纯虚析构函数</h4><ul>
<li>纯虚析构函数仍然需要函数体</li>
<li>目的：<strong>使基类成为抽象类，不能创建基类的对象</strong>。如果有其他函数是纯虚函数，则析构函数无论是否为纯虚的，基类均为抽象类。</li>
</ul>
<p>（why? 虽然是纯虚函数，但名字不同，故派生类中没必要再写一个名字相同的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base</span>()=<span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line">Base::~<span class="built_in">Base</span>() &#123;cout&lt;&lt;<span class="string">&quot;Base destroyed&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span>: <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive2</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Derive2</span>() &#123;cout&lt;&lt;<span class="string">&quot;Derive2 destroyed&quot;</span>&lt;&lt;endl;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base* p1 = <span class="keyword">new</span> Derive1;</span><br><span class="line">Base* p2 = <span class="keyword">new</span> Derive2;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line">cout &lt;&lt; “------” &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Base destroyed(也调用了Derive1，只不过是隐式定义的)</span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment">Derive2 destroyed</span></span><br><span class="line"><span class="comment">Base destroyed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/SekiroBlog/Lec.9.assets/image-20220425162411624.png" alt="image-20220425162411624"></p>
<h3 id="向下类型转换"><a href="#向下类型转换" class="headerlink" title="向下类型转换"></a>向下类型转换</h3><p>回顾：向上类型转换：<br>转换为基类指针或引用，则对应虚函数表仍为派生类的虚函数表（晚绑定）。<br>转换为基类对象，产生对象切片，调用基类函数（早绑定）。</p>
<p><strong>基类指针&#x2F;引用转换成派生类指针&#x2F;引用</strong>，则称为向下类型转换。（类层次中向下移动）</p>
<ul>
<li>当我们用基类指针表示各种派生类时(向上类型转换)，保留了他们的共性，但是丢失了他们的特性。如果此时要表现特性，则可以使用向下类型转换。</li>
<li>比如我们可以使用<strong>基类指针数组对各种派生类对象</strong>进行管理，当具体处理时我们可以将基类指针转换为实际的派生类指针，进而调用派生类专有的接口</li>
</ul>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul>
<li>C++提供了一个特殊的显式类型转换，称为dynamic_cast，是一种安全的向下类型转换。</li>
<li>使用dynamic_cast的对象必须有虚函数，因为它使用了<strong>存储在虚函数表中的信息判断实际的类型。</strong></li>
<li>使用方法：<br>obj_p，obj_r分别是T1类型的指针和引用<br>T2* pObj &#x3D; dynamic_cast&lt;T2*&gt;(obj_p);<br>&#x2F;&#x2F;转换为T2指针，运行时失败返回nullptr<br>T2&amp; refObj &#x3D; dynamic_cast&lt;T2&amp;&gt;(obj_r);<br>&#x2F;&#x2F;转换为T2引用，运行时失败抛出bad_cast异常<br>在向下转换中，T1必须是多态类型（声明或继承了至少一个虚函数的类），否则不过编译</li>
</ul>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><ul>
<li>如果我们知道正在<strong>处理的是哪些类型</strong>，可以使用static_cast来避免这种开销。<br>static_cast在编译时静态浏览类层次，<strong>只检查继承关系</strong>。没有继承关系的类之间，必须具有转换途径才能进行转换（要么自定义，要么是语言语法支持），否则不过编译。运行时无法确认是否正确转换。</li>
<li>static_cast使用方法：<br>obj_p，obj_r分别是T1类型的指针和引用<br>T2* pObj &#x3D; static_cast&lt;T2*&gt;(obj_p);<br>  &#x2F;&#x2F;转换为T2指针<br>T2&amp; refObj &#x3D; static_cast&lt;T2&amp;&gt;(obj_r);<br>  &#x2F;&#x2F;转换为T2引用<br>不安全：不保证指向目标是T2对象，可能导致非法内存访问</li>
</ul>
<h4 id="dynamic-cast与static-cast"><a href="#dynamic-cast与static-cast" class="headerlink" title="dynamic_cast与static_cast"></a>dynamic_cast与static_cast</h4><ul>
<li>相同点：<br>都可完成向下类型转换。</li>
<li>不同点：<br>static_cast在编译时<strong>静态</strong>执行向下类型转换。</li>
<li>dynamic_cast会在<strong>运行时</strong>检查被转换的对象<strong>是否确实是正确的派生类</strong>。额外的检查需要 RTTI (Run-Time Type Information)，因此要比static_cast慢一些，但是更安全。<br>一般使用dynamic_cast进行向下类型转换</li>
</ul>
<p><strong>Summary: 判断指针指向的是否是所需的真正对象</strong></p>
<p><strong>1）指针或引用的向上转换总是安全的；</strong><br><strong>2）向下转换时用dynamic_cast，安全检查；</strong><br><strong>3）避免对象之间的转换。</strong></p>
<p><img src="/SekiroBlog/Lec.9.assets/image-20220418140501192.png" alt="image-20220418140501192"><img src="/SekiroBlog/Lec.9.assets/image-20220418140827399.png" alt="image-20220418140827399"></p>
<p>应当清楚指向的是基类对象还是派生类对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span> &#123; <span class="keyword">public</span>:  <span class="keyword">virtual</span> ~<span class="built_in">Pet</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Pet &#123; </span><br><span class="line"><span class="keyword">public</span>: 	<span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;dog run&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">public</span> Pet &#123;</span><br><span class="line"><span class="keyword">public</span>: 	<span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;bird fly&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">(Pet* p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> d = <span class="built_in">dynamic_cast</span>&lt;Dog*&gt;(p);	<span class="comment">/// 向下类型转换</span></span><br><span class="line">	<span class="keyword">auto</span> b = <span class="built_in">dynamic_cast</span>&lt;Bird*&gt;(p);	<span class="comment">/// 向下类型转换</span></span><br><span class="line">	<span class="keyword">if</span> (d) <span class="comment">/// 运行时根据实际类型表现特性</span></span><br><span class="line">		d-&gt;<span class="built_in">run</span>();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(b)</span><br><span class="line">		b-&gt;<span class="built_in">fly</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Pet* p[<span class="number">2</span>];</span><br><span class="line">	p[<span class="number">0</span>] = <span class="keyword">new</span> Dog; <span class="comment">/// 向上类型转换</span></span><br><span class="line">	p[<span class="number">1</span>] = <span class="keyword">new</span> Bird; <span class="comment">/// 向上类型转换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">		<span class="built_in">action</span>(p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多重继承中的虚函数"><a href="#多重继承中的虚函数" class="headerlink" title="多重继承中的虚函数"></a>多重继承中的虚函数</h3><p><img src="/SekiroBlog/Lec.9.assets/image-20220425164056101.png" alt="image-20220425164056101"></p>
<p>多重继承的问题：</p>
<ul>
<li>二义性：如果派生类D继承的两个基类A,B，有同名成员a，则访问D中a时，编译器无法判断要访问的哪一个基类成员。</li>
<li>钻石型继承树（DOD：Diamond Of Death）带来的数据冗余：右图中如果 InputFile 和 OutputFile 都含有继承自 File 的 filename 变量，则 IOFile 会有两份独立的 filename，而这实际上并不需要。</li>
</ul>
<p><img src="/SekiroBlog/Lec.9.assets/image-20220418142236127.png" alt="image-20220418142236127"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhatCanSpeak</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">WhatCanSpeak</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;  &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhatCanMotion</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">WhatCanMotion</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">motion</span><span class="params">()</span> </span>= <span class="number">0</span>;   &#125;;<span class="comment">//提供接口，通用！与派生类无关</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> : <span class="keyword">public</span> WhatCanSpeak, <span class="keyword">public</span> WhatCanMotion</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;say&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">motion</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;walk&quot;</span> &lt;&lt; endl; &#125;<span class="comment">//实现函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSpeak</span><span class="params">(WhatCanSpeak* obj)</span> </span>&#123; obj-&gt;<span class="built_in">speak</span>(); &#125;<span class="comment">//调用函数，通用！与派生类无关</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doMotion</span><span class="params">(WhatCanMotion* obj)</span> </span>&#123; obj-&gt;<span class="built_in">motion</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Human human;</span><br><span class="line">	<span class="built_in">doSpeak</span>(&amp;human); <span class="built_in">doMotion</span>(&amp;human);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用虚函数实现动态的多态行为！隔离开“变”与“不变”</p>
<p>派生类改变，接口不变</p>
<h4 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 Polymorphism"></a>多态 Polymorphism</h4><ul>
<li>按照基类的接口定义，调用指针或引用所指对象的接口函数，函数执行过程因对象实际<strong>所属派生类的不同而呈现不同的效果</strong>（表现），这个现象被称为“多态”。</li>
<li>当利用基类指针&#x2F;引用调用函数时<br>虚函数在运行时确定执行哪个版本，取决于引用或指针对象的真实类型<br>非虚函数在编译时绑定</li>
<li>当利用类的对象直接调用函数时<br>无论什么函数，均在编译时绑定</li>
<li>产生多态效果的条件：继承 &amp;&amp; 虚函数 &amp;&amp; (引用 或 指针)</li>
<li><img src="/SekiroBlog/Lec.9.assets/image-20220418143002571.png" alt="image-20220418143002571"></li>
</ul>
<p>典例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123; </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">speak</span>();</span><br><span class="line">	<span class="built_in">motion</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Animal speak&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">motion</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Animal motion&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Bird singing&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">motion</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Bird flying&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Fish cannot speak ...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">motion</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Fish swimming&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Fish fish;</span><br><span class="line">  Bird bird;</span><br><span class="line">  fish.<span class="built_in">action</span>();	 <span class="comment">///不同调用方法</span></span><br><span class="line">  bird.<span class="built_in">action</span>();</span><br><span class="line"></span><br><span class="line">  Animal *pBase1 = <span class="keyword">new</span> Fish;</span><br><span class="line">  Animal *pBase2 = <span class="keyword">new</span> Bird;</span><br><span class="line">  pBase1-&gt;<span class="built_in">action</span>(); <span class="comment">///同一调用方法，根据</span></span><br><span class="line">  pBase2-&gt;<span class="built_in">action</span>(); <span class="comment">///实际类型完成相应动作 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/SekiroBlog/Lec.9.assets/image-20220418143338219.png" alt="image-20220418143338219"></p>
<h4 id="应用-TEMPLATE-METHOD-模板方法设计模式"><a href="#应用-TEMPLATE-METHOD-模板方法设计模式" class="headerlink" title="应用: TEMPLATE METHOD 模板方法设计模式"></a>应用: TEMPLATE METHOD 模板方法设计模式</h4><ul>
<li>在接口的一个方法中定义算法的骨架</li>
<li>将一些步骤的实现延迟到子类中</li>
<li>使得子类可以在<strong>不改变算法结构的情况下，重新定义算法中的某些步骤</strong>。</li>
<li>模板方法是一种<strong>源代码重用</strong>的基本技术，在类库的设计实现中应用十分广泛，因为这个设计模式能有效地解决 “类库提供公共行为”与“用户定制特殊细节”之间的折中平衡。</li>
</ul>
<p>有效框架：</p>
<p><img src="/SekiroBlog/Lec.9.assets/image-20220418143702100.png" alt="image-20220418143702100"></p>
<p><img src="/SekiroBlog/Lec.9.assets/image-20220418143709266.png" alt="image-20220418143709266"></p>
<p>可以通过继承和组合重用对象代码</p>
<p><strong>可以通过模板特征重用源代码</strong></p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>有些算法实现与类型无关，所以可以<strong>将函数的参数类型也定义为一种特殊的“参数”</strong>，这样就得到了“函数模板”。</li>
<li>定义函数模板的方法<br>template <typename T> ReturnType Func(Args)；</li>
<li>如：任意类型两个变量相加的“函数模板”<br>template <typename T><br>T sum(T a, T b) { return a + b; }&#x2F;&#x2F;需要加法运算符被重载过<br>注：typename也可换为class</li>
</ul>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><ul>
<li>函数模板在调用时，编译器能<strong>自动推导出实际参数的类型</strong>（这个过程叫做实例化）。<br>所以，形式上调用一个函数模板与普通函数没有区别，如<br>cout &lt;&lt; sum(9, 3); 		<br>cout &lt;&lt; sum(2.1, 5.7);</li>
<li>调用类型需要满足函数的要求。本例中，要求类型 T 定义了加法运算符。<br>当多个参数的类型不一致时，无法推导：<br>    cout &lt;&lt; sum(9, 2.1); &#x2F;&#x2F;编译错误</li>
<li>可以手工指定调用类型：sum<int>(9, 2.1)</li>
</ul>
<p>以排序为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(T* data, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123; <span class="comment">//选择排序</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(data[i] &gt; data[j])</span><br><span class="line">				std::<span class="built_in">swap</span>(data[i], data[j]); <span class="comment">//交换元素位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(T* data, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr_a[] = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="built_in">sort</span>(arr_a, <span class="number">5</span>);  <span class="comment">//调用int类型的sort</span></span><br><span class="line">	<span class="built_in">output</span>(arr_a, <span class="number">5</span>); <span class="comment">//调用int类型的output</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> arr_b[] = &#123;<span class="number">3.2</span>, <span class="number">2.1</span>, <span class="number">4.3</span>, <span class="number">1.5</span>, <span class="number">5.7</span>&#125;;</span><br><span class="line">	<span class="built_in">sort</span>(arr_b, <span class="number">5</span>); <span class="comment">//调用float类型的sort</span></span><br><span class="line">	<span class="built_in">output</span>(arr_b, <span class="number">5</span>);  <span class="comment">//调用float类型的output</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="模板生成的原理"><a href="#模板生成的原理" class="headerlink" title="模板生成的原理"></a>模板生成的原理</h4><p>对模板的处理是在编译期进行的，每当编译器发现对模板的一种参数的使用，就生成对应参数的一份代码。</p>
<p>也带来了问题：</p>
<p><strong>模板库必须在头文件中实现，不可以分开编译</strong>（请思考为什么？）</p>
<p>因为模板的原理是：在编译时，每发现一种模板参数的模板实例，就生成对应模板参数的代码。</p>
<p>如果使用源代码分开编译，则编译模板库的源代码时，编译器并不知道这一模板库有哪些模板实例；而编译模板实例时，又没有模板库的源代码来作生成。</p>
<p>因此会产生链接错误，没有生成对应模板参数的源代码。——不知道如何实现，无法链接</p>
<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>在定义类时也可以将一些类型信息抽取出来，用模板参数来替换，从而使类更具通用性。这种类被称为“类模板”。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(T _data): <span class="built_in">data</span>(_data) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; data &lt;&lt; endl; &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> A&lt;T&gt;::<span class="built_in">print</span>() &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; <span class="comment">//定义要带模板参数！</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	a.<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类模板的“模板参数”"><a href="#类模板的“模板参数”" class="headerlink" title="类模板的“模板参数”"></a>类模板的“模板参数”</h5><p>类型参数：使用typename或class标记<br><strong>非类型参数：整数，枚举，指针（指向对象或函数），引用（引用对象或引用函数）。无符号整数(unsigned)比较常用。</strong>如：<br>  template&lt;typename T, unsigned size&gt;<br>  class array {<br>      T elems[size];<br>  }; </p>
<p>  array&lt;char, 10&gt; array0; </p>
<p><strong>所有模板参数必须在编译期确定，不可以使用变量！！</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">array</span> &#123;</span><br><span class="line">  T elems[size];</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="comment">//array&lt;char, n&gt; array0; //不能使用变量</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> m = <span class="number">5</span>;</span><br><span class="line">  array&lt;<span class="type">char</span>, m&gt; array1; <span class="comment">//可以使用常量</span></span><br><span class="line">  array&lt;<span class="type">char</span>, 5&gt; array2; <span class="comment">//或具体数值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板与多态"><a href="#模板与多态" class="headerlink" title="模板与多态"></a>模板与多态</h3><ul>
<li>模板使用泛型标记，使用同一段代码，来关联不同但相似的特定行为，最后可以获得不同的结果。模板也是多态的一种体现。</li>
<li>但模板的关联是在编译期处理，称为<strong>静多态</strong>。（编译期多态）<ul>
<li>往往和函数重载同时使用</li>
<li>高效，省去函数调用</li>
<li>编译后代码增多</li>
</ul>
</li>
<li>基于继承和虚函数的多态在运行期处理，称为动多态<ul>
<li>运行时，灵活方便</li>
<li>侵入式，必须继承</li>
<li>存在函数调用</li>
</ul>
</li>
</ul>
<p>std标准模板库</p>
<h3 id="成员函数模板"><a href="#成员函数模板" class="headerlink" title="成员函数模板"></a>成员函数模板</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://sekiroyoumu.github.io/SekiroBlog/2022/04/28/hello-hexo/" data-id="cl2ip6zcl0000585ge5hn1z3c" data-title="hello hexo!" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/SekiroBlog/2022/04/28/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/SekiroBlog/archives/2022/04/">四月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/SekiroBlog/2022/04/28/hello-hexo/">hello hexo!</a>
          </li>
        
          <li>
            <a href="/SekiroBlog/2022/04/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Fangyi Chen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/SekiroBlog/" class="mobile-nav-link">Home</a>
  
    <a href="/SekiroBlog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/SekiroBlog/js/jquery-3.4.1.min.js"></script>



  
<script src="/SekiroBlog/fancybox/jquery.fancybox.min.js"></script>




<script src="/SekiroBlog/js/script.js"></script>





  </div>
</body>
</html>